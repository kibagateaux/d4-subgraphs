# https://github.com/messari/subgraphs/blob/master/schema-generic.graphql
interface Token {
  " Smart contract address of the token "
  id: ID!

  " Name of the token, mirrored from the smart contract "
  name: String!
  " Symbol of the token, mirrored from the smart contract "
  symbol: String!
  " The number of decimal places this token uses, default to 18 "
  decimals: Int!
  " Optional field to track the price of a token, mostly for caching purposes "
  lastPriceUSD: BigDecimal
  " Optional field to track the block number of the last token price "
  lastPriceBlockNumber: BigInt
}

type ETF implements Token @entity {
  id: ID!

  # standard token stuff
  name: String!
  symbol: String!
  decimals: Int!
  lastPriceUSD: BigDecimal
  lastPriceBlockNumber: BigInt

  totalSupply: BigInt!
  marketCap: BigInt!       # aka TVL
  components: [Component!]
  holders: [Holder!] @derivedFrom(field: "etf")
  pools: [Pool!] @derivedFrom(field: "baseToken")

  # if all done by governance then same address
  manager: Bytes
  methodologist: Bytes

  # in bps
  annualFee: BigInt
  mintFee: BigInt
  redeemFee: BigInt

  events: [Event!] @derivedFrom(field: "etf")
}

interface Event {
  id: ID!
  etf: ETF!
  
  block: BigInt!
  time: BigInt!
}

type MintEvent implements Event @entity {
  id: ID!
  etf: ETF!
  block: BigInt!
  time: BigInt!

  holder: Holder!
  amount: BigInt!
}

type RedeemEvent implements Event @entity {
  id: ID!
  etf: ETF!
  block: BigInt!
  time: BigInt!

  holder: Holder!
  amount: BigInt!
}

type TransferEvent implements Event @entity {
  id: ID!
  etf: ETF!
  block: BigInt!
  time: BigInt!

  holder: Holder!
  to: Holder!
  amount: BigInt!
}

type BuyEvent implements Event @entity {
  id: ID!
  etf: ETF!
  block: BigInt!
  time: BigInt!

  swap: Swap!
}

type SellEvent implements Event @entity {
  id: ID!
  etf: ETF!
  block: BigInt!
  time: BigInt!

  swap: Swap!
}


type Component implements Token @entity {
  id: ID! # "component - etf" address

  # standard token stuff
  name: String!
  symbol: String!
  decimals: Int!
  lastPriceUSD: BigDecimal
  lastPriceBlockNumber: BigInt

  etf: ETF! # ensure the 1 to many mapping on ETF
  allocation: Int! # % of etf invested in token
  amount: BigInt! # amount of Component per ETF
  isEligible: Boolean! # if tokemn should be in ETF according to methodology
  
  pools: [Pool!] @derivedFrom(field: "baseToken")
}

type Pool @entity {
  id: ID! # pool address
  totalSwapVolume: BigInt! # in base tokens
  totalSwapVolumeUsd: BigInt! 

  # assume that pools are uni 50/50 pools
  baseToken: Token!   # address of token we are tracking
  quoteToken: Token!  # address of other token in pool
  
  baseTokenBalance: BigInt!
  quoteTokenBalance: BigInt!

  swaps: [Swap!] @derivedFrom(field: "pool")
}

type Swap @entity {
  id: ID! # tx hash
  pool: Pool!
  trader: Holder!
  isBuy: Boolean! # if swap is buying token we are tracking

  tokenIn: Bytes!
  tokenInAmount: BigInt!
  tokenInUsd: BigInt!

  tokenOut: Bytes!
  tokenOutAmount: BigInt!
  tokenOutUsd: BigInt!
}

type Holder @entity {
  id: ID! # "holder - etf" address
  etf: ETF!
  amount: BigInt! #current holdings in ETF

  swaps: [Swap!] @derivedFrom(field: "trader")
  mints: [MintEvent!] @derivedFrom(field: "holder")
  redeems: [RedeemEvent!] @derivedFrom(field: "holder")
}
